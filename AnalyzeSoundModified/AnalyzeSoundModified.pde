/**
 * This sketch demonstrates how to use an FFT to analyze
 * the audio being generated by an AudioPlayer.
 * <p>
 * FFT stands for Fast Fourier Transform, which is a 
 * method of analyzing audio that allows you to visualize 
 * the frequency content of a signal. You've seen 
 * visualizations like this before in music players 
 * and car stereos.
 * <p>
 * For more information about Minim and additional features, 
 * visit http://code.compartmental.net/minim/
 */

import ddf.minim.analysis.*;
import ddf.minim.*;

Minim       minim;
AudioSample jingle;
FFT         fft;
AudioOutput out;
int counter, newCounter;
boolean played;
float spectrumScale = 4;
boolean[][] notes = new boolean[12*8][9080];
Octave[] octaves = new Octave[9];
Song thisSong;
float count;
NineOctaves moment;

void setup() {
  loadFreqs();
  count=0;
  frameRate(1000);
  counter=0;
  newCounter=0;
  played = false;
  size(1024, 200, P3D);
  minim = new Minim(this);
  thisSong = new Song(60);
  //jingle = minim.loadSample("jingle.mp3", 1024);
  //jingle = minim.loadSample("1-21 Thank You (Falettinme Be Mice Elf Agin).mp3", 1024);
  jingle = minim.loadSample("01 Lisztomania.mp3", 1024);
  fft = new FFT( jingle.bufferSize(), jingle.sampleRate() );
  fft.logAverages(22, 3);
  jingle.trigger();
  jingle.mute();
  moment = new NineOctaves();
  out = minim.getLineOut();
}

void draw() {
  background(0);
  if (millis()<=jingle.length()/2) {
    analyze2();
    count+=1.0/60.0;
  } else {
    jingle.stop();
  }
}

void analyze2() {
  float centerFrequency = 0;

  fft.forward( jingle.mix );

  for (int i = 0; i < fft.avgSize (); i++) {
    centerFrequency    = fft.getAverageCenterFrequency(i);
    float averageWidth = fft.getAverageBandWidth(i);   
    float lowFreq  = centerFrequency - averageWidth/2;
    float highFreq = centerFrequency + averageWidth/2;
    int xl = (int)fft.freqToIndex(lowFreq);
    int xr = (int)fft.freqToIndex(highFreq);
    color c = color(255);

    if (i<9) {
      c=drawRect(i);
      addLoudest(i, 1, xl, c);
    }
  }
  thisSong.add(moment);
}

color drawRect(int i) {
  fill(255);
  noStroke();
  color c;
  if (i%9==0) {
    c=color(255, 0, 0);
  } else if (i%9==1) {
    c=color(255, 100, 0);
  } else if (i%9==2) {
    c=color(255, 255, 0);
  } else if (i%9==3) {
    c=color(0, 255, 0);
  } else if (i%9==4) {
    c=color(0, 0, 255);
  } else if (i%9==5) {
    c=color(255, 0, 255);
  } else if (i%9==6) {
    c=color(0, 255, 255);
  } else if (i%9==7) {
    c=color(100, 100, 100);
  } else if (i%9==8) {
    c=color(255, 255, 255);
  } else {
    c=color(100);
  }

  fill(c);
  rect( 50+i*100, height, i, height - fft.getAvg(i)*10 );
  textSize(10);
  text(i, i*100+50, 100);
  noStroke();

  return c;
}

void addLoudest(int i, int number, int xl, color c) {
  int loudestIndex = -1;
  float loudestAmp = -1;
  boolean[] loudestIndices = new boolean[12];
  for (int k=0; k<12; k++) {
    loudestIndices[k] = false;
  }

  for (int times=0; times<number; times++) {
    for (int n=0; n<12; n++) {
      float f = octaves[i].getNote(n).getFreq();
      float a = fft.getBand(fft.freqToIndex(f));
      if (loudestIndex==-1 && !loudestIndices[n]) {
        loudestIndex=n;
        loudestAmp=a;
      }
      if (a>loudestAmp && !loudestIndices[n]) {
        loudestAmp = a;
        loudestIndex = n;
      }
    }

    loudestIndices[loudestIndex] = true;

    fill(c);
    ellipse(i*100-10+50, loudestIndex*12+50, loudestAmp/5, loudestAmp/5);
    if (thisSong.size()>0 && i!=1) {
      //moment.update(i, loudestIndex);
    }
    if (i<9) {
      float f = octaves[i].getNote(loudestIndex).getFreq();
      float a = fft.getBand(fft.freqToIndex(f));
      a = (int)a-(int)a%10;
      boolean loudEnough = false;
      
      println(a);

      if (i==0 || i==1) {
        loudEnough = a>=100;
      } else if (i==2) {
        loudEnough = a>=100;
      } else if (i==3) {
        loudEnough = a>10;
      } else if (i==4) {
        if (loudestIndex==0 || loudestIndex==7) {
          loudEnough=a>0;
        }
      } else if (i==5) {
          //loudEnough=a>0;
        if (loudestIndex==0 || loudestIndex==7) {
          loudEnough=a>0;
        }
      }else if(i==6){
        if (loudestIndex==0 || loudestIndex==7) {
          loudEnough=a>0;
        }
      }
      //      String printing = "";
      //      printing+=thisSong.size()+" ";
      //      printing+=loudestIndex+" ";
      //      printing+="0 is "+moment.getOctave(i).getNote(0).getPlayed()+"   7 is "+moment.getOctave(i).getNote(7).getPlayed();
      //      println(printing);
      //println(a+" "+loudestIndex);
      //println(moment.getOctave(i).getNote(loudestIndex).getPlayed()+" "+loudestIndex+" "+i);
      if (loudEnough) {
        if (moment.getOctave(i).getNote(loudestIndex).getPlayed()==0 ) {
          moment.getOctave(i).getNote(loudestIndex).setPlayed(2);
        } else if (moment.getOctave(i).getNote(loudestIndex).getPlayed()==2) {
          moment.getOctave(i).getNote(loudestIndex).setPlayed(1);
          //moment.update(i, loudestIndex);
        }
        if (moment.getOctave(i).getNote(loudestIndex).getPlayed()==2) {
          if (i==0 || i==1) {
            out.playNote(count*1.0/1000.0, 0.1, moment.getOctave(i).getNote(loudestIndex).getFreq());
            out.playNote(count*1.0/1000.0, 0.1, moment.getOctave(i).getNote(loudestIndex).getFreq());
            out.playNote(count*1.0/1000.0, 0.1, moment.getOctave(i).getNote(loudestIndex).getFreq());
            out.playNote(count*1.0/1000.0, 0.1, moment.getOctave(i).getNote(loudestIndex).getFreq());
          } else {
            out.playNote(count*1.0/1000.0, 0.1, moment.getOctave(i).getNote(loudestIndex).getFreq());
          }
        }
      } else {
        moment.getOctave(i).getNote(loudestIndex).setPlayed(0);
        //moment.update(i,loudestIndex);
      }
    }
    if (moment.getOctave(i).getNote(loudestIndex).getPlayed()==2) {
      //out.playNote(frameCount*1.0/1000.0,1.0,moment.getOctave(i).getNote(loudestIndex).getFreq());
    }
    for (int n=0; n<12; n++) {
      if (n!=loudestIndex) {
        moment.getOctave(i).getNote(n).setPlayed(0);
      }
    }
  }
}

void analyze() {
  // perform a forward FFT on the samples in jingle's mix buffer,
  // which contains the mix of both the left and right channels of the file
  fft.forward( jingle.mix );

  for (int o=2; o<5; o++) {
    for (int n=0; n<12; n++) {
      int index = fft.freqToIndex(octaves[o].getNote(n).getFreq());
      if (fft.getBand(index)>=10) {
        notes[12*o + n][counter] = true;
      } else {
        fft.setBand(index, 0);
        notes[12*o + n][counter] = false;
      }
    }
  }
  counter++;

  drawBands();
}

void drawBands() {
  stroke(255);
  for (int i = 0; i < fft.specSize ()/8; i++) {
    noStroke();

    if (i%6==0) {
      fill(255, 0, 0);
    } else if (i%6==1) {
      fill(255, 100, 0);
    } else if (i%6==2) {
      fill(255, 255, 0);
    } else if (i%6==3) {
      fill(0, 255, 0);
    } else if (i%6==4) {
      fill(0, 0, 255);
    } else if (i%6==5) {
      fill(255, 0, 255);
    }

    for (int j=0; j<octaves.length; j++) {
      int diameter = (int)fft.getBand(i)*2;
      ellipse(i*16, height/2, diameter, diameter);
    }
  }
}

void loadFreqs() {
  for (int i=0; i<9; i++) {
    octaves[i] = new Octave(i);
  }
}

